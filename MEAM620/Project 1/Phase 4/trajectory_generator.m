function [ desired_state] = trajectory_generator(t, qn, map, path)
% TRAJECTORY_GENERATOR: Turn a Dijkstra or A* path into a trajectory
%
% NOTE: This function would be called with variable number of input
% arguments. In init_script, it will be called with arguments
% trajectory_generator([], [], map, path) and later, in test_trajectory,
% it will be called with only t and qn as arguments, so your code should
% be able to handle that. This can be done by checking the number of
% arguments to the function using the "nargin" variable, check the
% MATLAB documentation for more information.
%
% map: The map structure returned by your load_map function
% path: This is the path returned by your planner (dijkstra function)
%
% desired_state: Contains all the information that is passed to the
% controller, as in phase 2
%
% It is suggested to use "persistent" variables to store map and path
% during the initialization call of trajectory_generator, e.g.
% persistent map0 path0
% map0 = map;
% path0 = path;

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% INITIAL SETUP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
persistent coef
persistent tt
velocity = 2.75;                                   %[m/s]
yaw = 0;                % Set yaw to 0
yawdot = 0;             % Set yawdot to 0

% tt = 10;              % Time to path completion.

num_inputs = nargin;    % Check the number of inputs to the function

if num_inputs == 4      % Assume this is the first time the function runs
    % Get the coefficients for each equation.  This is a persistent
    % variable.  This is a Mx4 matrix.
%     if size(path) == [1,4]
%         coef = [0 0 0 0 0 0];
%         return
%     end
    distan = sum(sqrt(sum((diff(path(:,1:3))).^2,2)));   % Total distance
    tt = distan/velocity;                         % Time to completion
    if tt>47;
        tt = 47;
    end
    distan = sqrt(sum((diff(path(:,1:3))).^2,2));
    [coef,tt] = startup(path,tt,distan);
    return
end

% t = t/tt; 
%% %%%%%%%%%%%%%%%%%%%%%%%%% GET TRAJECTORY %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if t>=tt
    t = tt;
end

% Basic equations for position, velocity, acceleration
mini = [1   t      t^2    t^3     t^4     t^5;
        0   1      2*t    3*t^2   4*t^3   5*t^4;
        0   0      2      6*t     12*t^2  20*t^3];
    
% mini = [1       t           t^2         t^3         t^4         t^5;
%         0       t^-.5       2*t^.5      3*t^1.5     4*t^2.5     5*t^3.5;
%         0       -t^-2/2     1/t         9/2         10*t        35/2*t^2];
% %         0       t^-3.5      -t^-2.5     0           10*t^-.5    35*t^.5;
% %         0       -3.5*t^-5   2.5*t^-4    0           5*t^-2      35/2*t^-1];
% Find the necessary coefficients
if sum(coef(:,4)==t)==6     % t is exactly the coefficients
    t_var1 = coef(:,4)==t;
    t_var2 = coef(:,4)>t;
    par_coef1 = coef(t_var1,1:3);
    par_coef2 = coef(t_var2,1:3);
    temp_coef = [par_coef1(end-2:end,:);par_coef2(1:3,:)];
elseif t == 0 % t is a start point
    mini = [1   t      t^2    t^3     t^4     t^5;
        0   1      2*t    3*t^2   4*t^3   5*t^4;
        0   0      2      6*t     12*t^2  20*t^3];
    t_var1 = coef(:,4)==t;
    t_var2 = coef(:,4)>t;
    par_coef1 = coef(t_var1,1:3);
    par_coef2 = coef(t_var2,1:3);
    temp_coef = [par_coef1(end-2:end,:);par_coef2(1:3,:)];
elseif t == tt % t is an end point
    t_var1 = coef(:,4)==t;
    t_var2 = coef(:,4)<t;
    par_coef1 = coef(t_var1,1:3);
    par_coef2 = coef(t_var2,1:3);
    temp_coef = [par_coef2(end-2:end,:);par_coef1(1:3,:)];
else
    t_var1 = coef(:,4)<t; 
    t_var2 = coef(:,4)>t;          % Never overlap so the less than or equal should be okay
    par_coef1 = coef(t_var1,1:3);
    par_coef2 = coef(t_var2,1:3);
    temp_coef = [par_coef1(end-2:end,:);par_coef2(1:3,:)];
end

% Still having trouble with the end point of the trajectory...

pos = mini(1,:)*temp_coef;
vel = mini(2,:)*temp_coef;
acc = mini(3,:)*temp_coef;

% Solve for the necessary trajectories
desired_state.pos = pos(:);
desired_state.vel = vel(:);
desired_state.acc = acc(:);
desired_state.yaw = yaw;
desired_state.yawdot = yawdot;
end

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%% UTILITY FUNCTIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [coef,finaltime] = startup(path,time,distan)
% INPUT:
%   path:   A list of [x y z index] coordinates of the path generated by 
%           DIJKSTRA or A*.  This is a Mx4 matrix.  The index parameter is
%           the position of the point relative to the others.  It may not
%           be a contiguous list 0,1,2,... if some points were removed to
%           smooth the path.
%   time:   The maximum time we would like the quadrotor to take to reach
%           the final destination.
%
% OUTPUT:
%   coef:   A set of coefficients needed to create a cubic spline across
%           the path.  This is a Mx3 matrix.

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% INITIAL SETUP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% path(end+1,:) = 2*path(end,:)-path(end-1,:);
equ_siz = 6;            % How many coef. are present in each equation
num_pts = size(path,1); % How many points are in the path

M = zeros(equ_siz*(num_pts-1),equ_siz*(num_pts-1));  % Create the empty matrix
v = zeros(equ_siz*(num_pts-1),4);                    % Create an empty vector to hold the coef.
% Symbolic variables & equations:
syms ti;                % time (t) used to generate the intial equ.
mini = [1   ti      ti^2    ti^3     ti^4     ti^5;
        0   1       2*ti    3*ti^2   4*ti^3   5*ti^4;
        0   0       2       6*ti     12*ti^2  20*ti^3;
        0   0       0       6        24*ti    60*ti^2;
        0   0       0       0        24       120*ti];

%% %%%%%%%%%%%%%%%%%%%%%%%%%% FILL MATRICES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Special case for first and last cases
% Replace ti with the proper number
mini_sub = double(subs(mini,ti,0));                             % Variable replacement
M(1:equ_siz/2,1:size(mini_sub,2)) = mini_sub(1:3,:);    % First case

% Fill the result vector.  This is a Mx4 vector.  One column for each
% variable.  The 4th column holds the time of each equation.
v(1,1) = path(1,1);
v(1,2) = path(1,2);
v(1,3) = path(1,3);
v(1:size(mini,2)/2,4) = zeros(size(mini,2)/2,1);


% mini = [1       ti           ti^2         ti^3         ti^4         ti^5;
%     0       ti^-.5       2*ti^.5      3*ti^1.5     4*ti^2.5     5*ti^3.5;
%     0       -ti^-2/2     1/ti         9/2         10*ti        35/2*ti^2;
%     0       ti^-3.5      -ti^-2.5     0           10*ti^-.5    35*ti^.5;
%     0       -3.5*ti^-5   2.5*ti^-4    0           5*ti^-2      35/2*ti^-1];    


% mini_sub = double(subs(mini,ti,time));
% M(end-equ_siz/2+1:end,end-equ_siz+1:end) = mini_sub(1:3,:);
% % M(end-equ_siz/2+1:end,end-size(mini_sub,2)+1:end) = test;
% v(end-size(mini,2)/2+1,1) = path(end,1);
% v(end-size(mini,2)/2+1,2) = path(end,2);
% v(end-size(mini,2)/2+1,3) = path(end,3);
% v(end-size(mini,2)/2+1:end,4) = ones(size(mini,2)/2,1)*time;

%%% TEMPORARY CODE! %%%%%
% Add indices to path
% path(1:end,4) = 0:(num_pts-1);
delta = distan;
distan = cumsum(distan);
vel = distan(end)/time;
t_prior = 0;
const = 3;
root = 2;
for index = 2:num_pts-1   % Gen "mini" for each point and add to M
    t_real = nthroot(delta(index-1),root)/vel*const;  % The time when the 
                                                % quadrotor should reach
                                                % this pt.

    t_real = t_real+t_prior;
    % Substitute the variable t in mini with t_real
    mini_sub = double(subs(mini,ti,t_real));
    
    posx1 = equ_siz*(index-1)+1;                    % 1st x position of mini
    posx2 = equ_siz*(index-2)+1;                    % 2nd x position of mini
    posy  = (equ_siz)*(index-1)-equ_siz/2+1;        % y position of mini

    
    % Place mini into M
    M(posy:posy+equ_siz/2-1,posx2:posx2+size(mini_sub,2)-1) = mini_sub(1:3,:);
    M(posy+equ_siz/2:posy+equ_siz-1,posx1:posx1+size(mini_sub,2)-1) = mini_sub(1:3,:);
    
    v(posy+equ_siz/2,1) = path(index,1);
    v(posy,1) = path(index,1);
    v(posy+equ_siz/2,2) = path(index,2);
    v(posy,2) = path(index,2);    
    v(posy+equ_siz/2,3) = path(index,3);
    v(posy,3) = path(index,3);
    v(posy:posy+size(mini_sub,1),4) = ones(size(mini,2),1)*t_real;
    t_prior = t_real;
end

t_real = nthroot(delta(end),root)/vel*const; % The time when the 
                                            % quadrotor should reach
                                            % this pt.
t_real = t_real+t_prior;                  
mini_sub = double(subs(mini,ti,t_real));
M(end-equ_siz/2+1:end,end-equ_siz+1:end) = mini_sub(1:3,:);
% M(end-equ_siz/2+1:end,end-size(mini_sub,2)+1:end) = test;
v(end-size(mini,2)/2+1,1) = path(end,1);
v(end-size(mini,2)/2+1,2) = path(end,2);
v(end-size(mini,2)/2+1,3) = path(end,3);
v(end-size(mini,2)/2+1:end,4) = ones(size(mini,2)/2,1)*t_real;

% Convert M to a sparse matrix for easier solving
M = sparse(M);

%% %%%%%%%%%%%%%%%%%%%%%%%%% SOLVE THE MATRIX %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Solve for coefficients
coef = [M\v(:,1:3) v(:,4)];
finaltime = t_real;
end